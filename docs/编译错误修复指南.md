# 编译错误修复指南

## 问题根源

创建 Redis 仓储时，没有正确理解实体的结构：

### 实体属性对照表

| Redis 仓储中使用的属性 | 实际实体属性 | 说明 |
|----------------------|------------|------|
| `Order.Symbol` | `Order.TradingPair.Symbol` | Order 没有 Symbol，需要通过导航属性获取 |
| `Order.CreatedAt/UpdatedAt` (DateTimeOffset) | `Order.CreatedAt/UpdatedAt` (long) | 时间戳是 long 类型 |
| `OrderStatus.Open` | `OrderStatus.Active` | 枚举值不同 |
| `Asset.Currency` | `Asset.Symbol` | 属性名称不同 |
| `Asset.AvailableBalance` | `Asset.Available` | 属性名称不同 |
| `Asset.FrozenBalance` | `Asset.Frozen` | 属性名称不同 |
| `Trade.Symbol` | `Trade.TradingPair.Symbol` | Trade 没有 Symbol |
| `Trade.BuyerUserId` | `Trade.BuyerId` | 属性名称不同 |
| `Trade.SellerUserId` | `Trade.SellerId` | 属性名称不同 |
| `Trade.Timestamp` | `Trade.ExecutedAt` | 属性名称不同 |

## 需要修复的文件

### 1. RedisOrderMatchingEngine.cs

**问题**：
- 使用 `order.Symbol` 应该改为从 TradingPair 获取 symbol
- 使用 `OrderStatus.Open` 应该改为 `OrderStatus.Active`
- `order.UserId` 可能为 null，需要处理
- `order.Price` 可能为 null，需要处理
- Trade 实体属性名称错误

**修复方案**：
1. PlaceOrderAsync 需要接收 symbol 参数或查询 TradingPair
2. 所有 OrderStatus.Open 改为 OrderStatus.Active
3. 所有 order.UserId 使用时加 .Value (或 ?? 0)
4. Trade 实体使用正确的属性名

### 2. RedisMySqlSyncService.cs

**问题**：
- Order/Asset/Trade 映射时使用错误的属性名
- DateTimeOffset 赋值给 long 类型
- 使用了不存在的 `Currency` 属性

**修复方案**：
1. MapToOrder: CreatedAt/UpdatedAt 直接使用 long.Parse
2. Asset 查询使用 `a.Symbol` 而非 `a.Currency`
3. Trade 映射使用正确的属性名

### 3. ServiceCollectionExtensions.cs

**问题**：
- 命名空间错误：`RedisDataLoaderService` 在 `CryptoSpot.Infrastructure.BgService` 而非 `BgServices`

**修复方案**：
```csharp
using CryptoSpot.Infrastructure.BgService;
```

## 推荐的快速修复步骤

由于文件太多且修改复杂，建议：

1. **删除所有 Redis 相关文件**
2. **重新设计 Redis 仓储架构**，考虑：
   - Order 在 Redis 中存储时需要冗余 symbol 字段
   - Trade 在 Redis 中存储时需要冗余 symbol 字段
   - 使用统一的时间戳类型（long）
   - 使用统一的属性命名（与实体一致）

3. **或者临时方案**：
   - 修改 RedisOrderMatchingEngine，从数据库查询 TradingPair.Symbol
   - 所有地方显式处理可空类型
   - 修正所有属性名称映射

## 建议

鉴于错误数量和复杂度，推荐以下两种方案之一：

### 方案 A：渐进式修复（安全）
1. 先修复命名空间问题
2. 逐个文件修复编译错误
3. 测试每个修复

### 方案 B：重构（彻底）
1. 保留 Redis 数据加载服务
2. 暂时注释掉 RedisOrderMatchingEngine 和同步服务
3. 先实现简单的 Redis 缓存功能
4. 逐步添加完整功能

**推荐使用方案 A**，因为大部分代码逻辑是正确的，只是属性映射问题。
